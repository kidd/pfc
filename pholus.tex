%\documentclass[titlepage,a4paper,12pt]{book}
%\usepackage[utf8]{inputenc}
%\usepackage[catalan]{babel}
%\usepackage{graphicx}
%\usepackage{verbatim}
%\usepackage{marvosym}
%\usepackage{amssymb, amsmath} 
%\usepackage{listings}
%\usepackage{textcomp}
%\usepackage[]{color}
%\begin{document}
%\tableofcontents  %%Index

\chapter{Pholus} % (fold)
\label{cha:Pholus}

\section{Objectius} % (fold)
\label{sec:Objectius}
%-------------------ININATXO-------------------
Aquest projecte anomenat \texttt{Pholus}, és el mòdul que aporta la ``intel·ligència'' d'una tecnologia
molt més general desenvolupada a Intelligent Pharma, anomenada \texttt{Helios}. A continuació descriurem
en línies generals Helios, tot i que estrictament no forma part del present PFC, i un cop explicat es detallarà
la necessitat tecnològica que ha originat el desenvolupament de Pholus.

%ha estat desenvolupat per a equilibrar
%(ponderar) pesos dels diferents indicadors de semblança entre molècules, per a
%veure quins són més rellevants en discriminar les que poden tenir una activitat
%més òptima en front una diana. 

%Es tracta d'un algoritme evolutiu relativament senzill pel que fa al propi algoritme, però més
%complex pel referent a les condicions externes que s'imposen per la natura, i que ens obliguen a
%posar condicions i limitacions al Algoritme Evolutiu (als Algoritmes Evolutius
%no els agraden les limitacions).

Helios és una tecnologia que serveix per identificar, a partir d'una molècula de referència prèviament donada,
noves molècules amb propietats estructurals completament diferents que imitin el comportament de la molècula de
referència. D'aquesta manera, si el compost de referència ja és conegut (per exemple, un extret d'un
producte natural o d'una patent), Helios pot trobar altres composts no vinculats estructuralment que
reprodueixin les seves propietats biològiques i farmacològiques però amb una estructura mol·lecular completament diferent.
Aquesta cerca se l'anomena ``\emph{scaffold hopping}'' (salts entre diferents famílies d'estructures químiques).

Aquest concepte és el que tècnicament es coneix com \emph{Virtual Screening} (VS) o cribatge virtual,
el qual, normalment s'utilitza per descobrir noves famílies químiques en relació a una activitat biològica
desitjada. Hi ha diversos mètodes de VS que es basen en l'estructura dels compostos (VS basat en lligands) i d'altres que no
(VS basat en receptor). Com hem dit, Helios té com a objectiu identificar nous compostos que no són anàlegs estructuralment,
però sí biològicament i per tant és un VS basat en lligands.

Helios es basa en la superposició de camps mol·leculars entre qualsevol compost i un lligand de
referència. Però Helios, no només considera la superposició generada per càrregues formals, sinó
també altres tipus relacionades amb el comportament dinàmic; així, es fan diferents superposicions
entre parells de mol·lècules es duen a terme a la vegada. L'alineament de camps mol·leculars va ser descrit durant els anys noranta \ref{WHW04},
però no s'ha dut a terme fins aquesta dècada degut a que l'alineament mol·lecular flexible és un problema que requereix
grans capacitats supercomputacionals. Fins els últims anys, el problema del VS basat en lligands s'ha hagut de simplificar
focalitzant-se en tècniques d'identificació de semblances moleculars com l'estructura, farmacòfor, etc. 

Usant ``cloud computing'', Helios realitza alineaments de camps moleculars flexibles per identificar els compostos que s'assemblin
al compost de referència. Els compostos amb els quals es fa l'alineament es treuen d'una base de dades que pot variar segons l'objectiu de la cerca, i
poden anar des de uns pocs milers de composts fins a milions. En aquests moments, usant la infraestructura MareNostrum (192 elements de procés, per càlcul)
una base de dades de 10.000 composts triga en ser analitzada, aproximadament, unes 15 hores.

Els camps moleculars són discretitzats dins d'una caixa en forma de xarxa (grid) de punts. Concretament, Helios processa 22 camps de potencials diferents (veure taula \ref{table:maps}), els quals són representacions que donen informació sobre la densitat electrònica i són construïts amb sondes atòmiques. Una sonda atòmica és una partícula amb
característiques químiques particulars que s'assemblen a propietats atòmiques en ambients electrònics particulars. 

Amb això obtenim per a cada mol·lècula de la base de dades 22 vectors on hi ha els valors per cadascun dels punts ordenats del grid de les 22 sondes moleculars
alineades amb la molècula de referència. A partir d'aquí hem de trobar la manera d'avaluar la similitud entre ambdues mol·lècules. Per fer-ho, Helios utilitza una mètrica
basada en la distància de Tanimoto (explicada més endavant), però s'ha de trobar com pondera cadascuna de les similituds (o distàncies) de Tanimoto dels 22 camps de
potencials per a calcular la similitud final, ja que els 22 mapes de potencials calculats no tenen la mateixa importància de cara a determinar si dues molècules tenen
la mateixa activitat biològica o no.

Per tant, l'{\bf objectiu del projecte Pholus és dissenyar, implementar i validar un sistema intel·ligent que pugui calibrar el pes de cadascuna de les 22 distàncies de
Tanimoto en el còmput final de la puntuació de similitud entre dues molècules determinades}, o, en altres paraules, que el sistema pugui determinar, per a cada problema
biomèdic concret, la importància de cadascuna de les 22 propietats fisico-químiques per tenir una ponderació final en el càlcul de similituds entre les parelles de molècules.
Per fer-ho, cal que per a cada execució (o problema biomèdic diferent) l'usuari proporcioni al sistema un conjunt de molècules amb activitats biològiques conegudes
(tant actives, inactives com d'activitat desconeguda) per a que Pholus pugui determinar el pes de les 22 propietats fisico-químiques en aquell problema en concret.

Per abordar aquest objectiu científic s'ha analitzat la viabilitat de dues tecnologies molt diferents, com són la anàlisi de components principals (PCA) i algoritmes evolutius.
Després de fer les corresponents comparatives (no incloses en el present PFC) es va triar implementar algorismes evolutius per a resoldre el problema. Finalment, també
s'ha analitzat el problema del sobreentrenament, com és necessari en qualsevol altre projecte d'aprenentatge artificial.


%--------------------FINATXO-------------------

%Aquest projecte anomenat \texttt{Pholus}, ha estat desenvolupat per a equilibrar
%(ponderar) pesos dels diferents indicadors de semblança entre molècules, per a
%veure quins són més rellevants en discriminar les que poden tenir una activitat
%més òptima en front una diana. 

%Es tracta d'un algoritme evolutiu relativament senzill pel que fa al propi algoritme, però més
%complex pel referent a les condicions externes que s'imposen per la natura, i que ens obliguen a
%posar condicions i limitacions al Algoritme Evolutiu (als Algoritmes Evolutius
%no els agraden les limitacions).

%Pholus forma part de la nova tecnologia desenvolupada per Intelligent Pharma, anomenada HELIOS, que
%serveix per identificar,a partir d'un compost de referència prèviament donat, nous compostos amb
%propietats estructurals completament diferents que imiten el comportament d'aquest compost de
%referència. Per exemple, si el compost de referència ja és conegut (per exemple, un extret d'un
%producte natural o d'una patent), HELIOS pot trobar compostos no  vinculats estructuralmnt que
%reprodueixin les seves propietats psico-químiques tridimensionals; per tant, aquests compostos
%tindran les mateixes característiques biològiques però amb diferent estructura mol·lecular. A
%aquesta búsqueda se l'anomena "Scaffold hopping" (búsqueda entre diferents famílies químiques).

%La tècnica utilitzada és el Virtual Screening(VS), que normalment s'utilitza per descobrir noves
%famílies químiques en relació a una activitat biològica desitjada. El VS té mètodes que es basen en
%l'estructura dels compostos i d'altres que no. Com hem dit, HELIOS té com a objectiu identificar
%nous compostos que no són anàlegs estructuralment, però sí biològicament. 

%HELIOS es basa en la superposició de camps mol·leculars entre qualsevol compost i un lligand de
%referència. Però HELIOS, no només considera la superposició generada per càrregues formals, sinó
%també altres tipus relacionades amb el comportament dinàmic; així, es fan diferents superposicions
%entre parells de mol·lècules es duen a terme a la vegada. 
%L'alineament de camps mol·leculars va ser descrit durant els anys noranta, però no s'ha dut a terme
%fins aquesta dècada degut a que l'alineament mol·lecular flexible és un problema impossible de
%resoldre sense les eines de supercomputació. Fins els últims anys, el Virtual Screening basat en els
%lligands s'ha basat en metodologies per buscar semblances moleculars com l'estructura, farmacòfor,
%etc. 

%HELIOS utilitza alineaments de camps moleculars flexibles per identificar compostos que s'assemblin
%a un compost de referència. L'alineament molecular e duu a terme mitjançant tècniques de "cloud
%computing", la qual permet fer-ho en pocs dies. Els compostos amb els quals es fa l'alineament es
%treuen d'una base de dades que pot variar segons l'objectiu de la cerca. 

%Els camps moleculars són discretitzats dins d'una caixa en forma de grid de punts. Idealment, la
%caixa hauria de ser suficientment gran per introduir-hi tots els lligands de la base de dades en una
%conformació estesa. De la mateixa manera la capsa ha d'incloure aquells punts al voltant de les
%molècules que tenen valors significatius. Diferents representacions dels camps moleculars, que donen
%diferent informació sobre la densitat electrònica, són construïts amb sondes atòmiques. Una sonda
%atòmica és una partícula amb característiques químiques particulars que s'assemblen a propietats
%atòmiques en ambients electrònics particulars.  Podem veure les 22 sondes atòmiques
%implementades en HELIOS en la taula \ref{table:maps}.

L'alineament múltiple de camps moleculars flexibles és una taxa complexa que requereix de tècniques i recursos computacionals avançats. El procés implementat per HELIOS fixa el camp molecular del compost de referència i utilitza algoritmes evolutius en un sistems de "cloud-computing" per duu a terme l'alineament flexible múltiple dels camps moleculars de cadascún dels diferents compostos que hi ha dins la base de dades.

Amb això obtenim per a cada mol·lècula de la base de dades 22 vectors on hi ha els valors per cadascún dels punts ordenats del grid de les 22 sondes moleculars. A partir d'aquí hem de trobar alguna manera d'avaluar la similitud entre mol·lècules.

Com es mostrarà en les següents seccions, hi ha una part important de feina
realitzada en la preparació de les dades, i en la corresponent validació dels
resultats a part del propi algorisme evolutiu.

% section Objectius (end)

\section{Context Químic} % (fold)
\label{sec:Context Quimic}
%XXX Tanimotos, conformacions, y tal 

El problema al que ens enfrontem és el de, donat un \texttt{receptor} i un conjunt de %glossari
lligands, deduir quins són els factors que fan que la unió sigui millor
o pitjor.  Els factors que intervenen en aquesta unió són molts, però a nivell
pràctic, utilitzem 22 indicadors de potencial, que són els que podem quantificar amb
facilitat, i que hem cregut que tenen més rellevància en aquest procés.

Aquests indicadors són els mostrats en la taula \ref{table:maps}.

\begin{table}
\centering
\begin{tabular}{|cc|}
\hline
aromatic carbon             & aliphatic carbon\\
non-hydrogen bonding sulfur & non-hydrogen bonding phosphor\\
phosphor                    & non-hydrogen bonding nitrogen\\
hydrogen donor              & oxygen acceptor\\
nitrogen acceptor           & sulfur acceptor\\
spherical nitrogen acceptor & spherical oxygen acceptor\\
fluorine                    & chlorine\\
bromine                     & iodine\\
iron                        & manganese\\
calcium                     & magnesium\\
zinc                        & positive charge\\
\hline
\end{tabular}
\caption{Les 22 sondes d'àtom implementades en HELIOS.}
\label{table:maps}
\end{table}

Per tal que una unió entre lligand i receptor sigui bona, les energies
dissipades s'han de minimitzar, mostrant així que entre les dues molècules es
neutralitzen.  Si la energia és alta, fa que la estructura final (lligand +
receptor) sigui poc estable i fàcilment trencada, ja que les dues parts, poden
trobar alguna altra formació on ``es troben més còmodes'' i desfan la unió que
tenien.

% XAVISTART

Per començar, hem d'imaginar una molècula com un graf en un espai de tres
dimensions, on els nodes són els àtoms, i les arestes són enllaços.  En general,
semblança $S_{A,B}$ entre dos objectes és estimada pel nombre d'elements iguals
que tenen. Els objectes que són iguals, haurien de tenir la màxima puntuació.
Per tant, una expressió de la semblança sería en termes de la teoria de
conjunts, la intersecció $(A\cap B)$ que en lògica seria l'operador $AND$. La
dissimilitud $D_{A,b}$ és estimada pel nombre d'elements diferents que tenen.
Els objectes idèntics obtindrien la mínima puntuació. Anàlogament a la
similitud, parlant en termes de teoria de conjunts, la dissimilitud es
calcularia posant amb la unió $(A\cup B)$ o el que seria el mateix amb
l'operador lògic $OR$. El denominador serà simplement un normalitzador per tenir
l'índex entre 0 i 1. 

El concepte de semblança normalment s'utilitza per referir-se tan a la semblança
com a la diferència, ja que es suposa que si dos objectes són semblants és
perquè no són diferents. En matemàtiques i estadística s'utilitzen els conceptes
de semblança, proximitat i distància per referir-se al mateix, però en química,
similitud i dissimilitud poden portar a diferents resultats. Per exemple,
considerem dues seqüències de caràcters, F1 i F2, cadascuna té conjunts de 407
caràcters, 402 dels quals són comuns entre ells. F3 i F4, cadascuna té un
conjunt de 5 caràcters, dels quals cap d'ells és comú. En els dos casos la
distància Euclídia és $10 \over 1024$  o $0.0098$ quan és evident que les dues
primeres són més semblants entre elles que la segona parella.

%Continues vs Discretes? bedroc.tex pag 11

Mètriques per a mesurar els potencials i les diferències (o semblances) entre
ells n'hi ha moltes, unes funcionen millor per a dades qualitatives, altres per
a quantitatives, i n'hi ha que fins i tot utilitzen la falta d'informació per a
establir similituds.  Això últim, en el nostre context no ens interessa tant com
tenir una mesura que ens serveixi per a dades quantitatives, i a ser possible,
acoti els valors entre dos llindars coneguts.

Hem de tenir en compte el cost de calcular les diferències entre
molècules, ja que serà un procés a repetir moltes vegades, i en gran
número de molècules, i hem d'intentar trobar un coeficient que sigui
viable de calcular.  Ens hem decidit per una variació de Tanimoto
\ref{ssub:Tanimoto}, acotada entre -1 i +1 que s'explicarà tot seguit.

%XAVISTOP  XXX

%Tanimotos. Què cony son? %XXX
\subsubsection{Tanimoto} % (fold)
\label{ssub:Tanimoto}

Com hem dit a l'apartat anterior, hem seleccionat el coeficient de
Tanimoto. El coeficient de Tanimoto és definit com la mida de la
intersecció dividida per la mida de la unió dels conjunts de
mostra. Si A i B són dos conjunts, en termes de la teoria de conjunts
el coeficient de Tanimoto és igual a

$$T(A,B)={|A\cap B| \over |A\cup B|}$$

Per tant, si tractem amb vectors el coeficient tindrà la següent expressió: 

$$T(A,B)={A \cdot B \over \|A\|^{2} + \|B\|^{2} - A·B}$$

Els vectors de dades (de potencials) amb què treballem nosaltres
pertanyen a $\Re^{N}$ on N són el nombre de punts que s'han considerat
dins el grid. L'adaptació que fem nosaltres és convertir-los a vectors
binaris de manera que només es consideren potencials rellevants. La
unió de dos camps moleculars alineats són tots aquells punts de
l'espai on qualsevol dels dos camps presenta potencials de Van der
Waals menors de -0.1 i el valor absolut del potencial electrostàtic és
més gran que 0.5 o amb potencials de desolvatació més grans que
0.25(C'). La intersecció són tots aquells punts de la unió que
presenten diferències entre els camps moleculars més petites de
0.25(C). Per tant, el nostre coeficient de Tanimoto modificat és
definit com:

$$T'_{j}(A_{j},B_{j})={C_{j} \over C'_{j}}$$

on j és un camp molecular donat. Un cop $T'_{j}$ és calculat per
cadascun dels 22 camps moleculars, el coeficient de Tanimoto final,
$T'_{i}$ (compost de referència i), és calculat amb una mitjana
aritmètica ponderada:

$$T'_{i}={\sum_{j=0}^{n} \omega_{j}\cdot T'_{i,j} \over \sum_{j=0}^{n} \omega_{j}}$$

L'últim pas va ser trobar una ponderació general dels 22 coeficients
de Tanimoto. La primera ponderació utilitzada va ser trobada sota
criteris químics. Llavors es va realitzar un anàlisi de components
principals sobre una base dades de 1534 molècules i amb una molècula
de referència. Els resultats obtinguts van ser millors que amb la
ponderació sota criteris químics.

Obtinguts aquests resultats es va agafar la mateixa base de dades i es
va calcular els coeficients de Tanimoto amb 10 molècules de referència
diferents i es va realitzar un anàlisi canònica de poblacions per
veure si es podia trobar una ponderació única, i els resultats
obtinguts van mostrar que no era possible. Per tant, degut a l'alt
cost computacional que tindria fer un anàlisi de components principals
per cada càlcul s'ha optat per mantenir la ponderació sota criteris
químics, ja que aquesta en global donava millors resultats que la
ponderació obtinguda per anàlisi de components principals.


Per a calcular els valors dels 22 potencials de cada lligand, es resten els
potencials de la molècula de referència amb els del lligand.  El format en el
que estan ambdues molècules, és el mateix, però pot ser que estiguin situades en
un espai diferent respecte el 0 del eix de coordenades (recordem que estan
mapejades en un espai 3D).  Per a ajustar les dues molècules, es passen per un
procés de docking (autodock), que el que fa és ajuntar-les de la millor manera que pot
(també utilitza algoritmes genètics per a fer-ho) simulant la seva unió. Una
vegada tenim els dos grafs ``superposats'' de la millor manera, calculem les
diferències entre els potencials d'una i de l'altre estructura en cada punt, i
després podem fer una resta dels valors punt a punt.  Això ho podem fer gràcies
a què hem reduït les dues molècules a ocupar el màxim espai comú, i els
potencials en cada punt $i$ de la matriu de la molècula de referència, pot ser
relacionat i comparat amb el punt $i$ de la matriu d'un lligand.

Després de fer tots els càlculs i restes pels 22 diferents tipus de potencials,
podem donar un número de semblança ``total'' per dos molècules i un tipus de
potencial.

% \begin{center}
%   $2[\mid\chi_{A}\cap\chi_{B}\mid]/[\mid\chi_{A}\mid+\mid\chi_{B}\mid]^{1/2}$
% \end{center}


% subsubsection Tanimoto (end)


\subsubsection{Bedroc}
\label{ssub:Bedroc}
%XXX
Una vegada sabem com hem de calcular la distància entre dues molècules, necessitem 

''Virtual Screening'' és un terme que s'aplica a un tipus de problema
que conceptualment és l'equivalent computacional de ....... screening, %XXX
o sigui, a on un gran nombre de mostres (mol·lècules en aquest cas)
estan disposades per ser discriminades entre actives i inactives. Per
Intelligent Pharma avaluar l'execució del VS és una pràctica
necessària, ja que és una forma de seleccionar quin mètode ordena
millor. Com hem indicat en l'apartat anterior avaluar el VS ens
servirà per comparar entre diferents ponderacions, o sigui, per
determinar quina ponderació discrimina millor entre mol·lècules
actives i inactives.

L'èxit en el ''Virtual Screening'' està en trobar un bon coeficient
que assigni bones puntuacions a les molècules interessants(normalment
definides com a actives respecte a una proteïna) i males puntuacions a
les mol·lècules menys interessants (inactives). Per tant, un virtual
screening exitós posarà a d'alt de tot de la llista ordenada les
mol·lècules actives i després les inactives.

A partir d'ara el que tenim és una llista ordenada de mol·lècules i
volem saber si l'ordenació obtinguda és adequada al nostre problema,
per tal de poder comparar diferents coeficients i diferents
ponderacions. De fet, això no es restringeix només al ''Virtual
Screening'', és un problema universal de tots els exercicis de
predicció. Això ens pot ajudar a l'hora de trobar aproximacions de la
bondat de l'ordenació. El problema és que el Virtual Screening té una
particularitat, i és que la proporció d'actius a posar a d'alt de tot
de la llista és molt petita, i pot provocar molt biaix a l'hora de fer
la predicció. Aquest problema en la literatura és conegut com el
''early recognition problem''. Aquest tema ha estat de gran interès en
molts àmbits tan acadèmics com de la indústria farmacèutica en els
últims anys. En aquest apartat estudiarem diferents maneres de tractar
el problema presentat.

Maneres d'avaluar ordenacions n'hi ha moltes(AUAC,ROC,Enrichment
Factor, RIE, BEDROC), i s'han analitzat unes quantes, però només
s'explicarà la utilitzada finalment

XXX : IMPORTANT
% subsubsection Bedroc (end)

\subsubsection{Estereoisomers i conformacions}
\label{ssub:estereoisomers i conformacions}

Una altra particularitat del problema és la varietat de estereoisomers i de
conformacions que pot tenir una molècula donada.  Una molècula, identificada per
un nom i una composició pot tenir diverses maneres de mapejar-se en un espai
tridimensional.

Quan diem que una molècula pot tenir varis estereoisomers, ens referim a que
dues molècules, poden ser simètriques, però no superposables.  Un exemple al que
podem estar més acostumats, per entendre el concepte són les mans.  La mà dreta
i la esquerra, tindrien la mateixa composició, però al ser simètriques una
respecte la altra, fa que no puguem superposar-les.

Cada estereoisomer pot tenir diverses conformacions.  Amb això ens referim a què
en la natura, no sempre trobem la molècula amb els mateixos angles entre àtoms,
tipus d'enllaços, etc. Per exemple, una molècula pot trobar-se en la natura
enrotllada sobre ella mateixa, o bé estirada (és bastant comú trobar aquests
tipus de conformacions).

%XXX Fotos de isomers i conformacions

Quan sabem que una molècula és activa, podem no tan sols buscar la minimització
d'energia (és una feina costosa, i no podem controlar tots els agents externs
presents en l'entorn), sinó que podem, simplement refiar-nos de que sabem
empíricament que la activitat d'un lligand amb un receptor.

%XXX quan tenim molècules actives, no tenim la conf ni isomer, i hem de buscar
%d'entre totes, la millor, i fiarnos que aquella es la bona, per comparar amb
%les que busquem


El que utilitzem és la informació de molècules que sabem que són actives,
i elaborem tot el procediment per a descobrir quines condicions compleixen entre
elles que les pot fer actives.

Així doncs, les dades que tenim com a entrada són simplement els 22 valors per a cada isomer i
conformació de cada molècula, i una llista de quines d'elles sabem del cert que presenten activitat
contra un receptor donat.  El que volem aconseguir és doncs, 22 factors, pels que multiplicar els 22
\textbf{tanimotos} i que al sumar-los, ens donin una ordenació de les molècules, situant les actives
en les primeres posicions (un index de activitat?).

% XXX Formula

Inicialment, hem provat la intuïció química, per decidir quin tipus de
indicadors són els més rellevants, i ajudats amb eines estadístiques, hem
aconseguit trobar unes ponderacions que situen la majoria de molècules actives
en les primeres posicions, però el procés és manual, i no assegura ni la
ordenació actives/inactives, ni la pròpia ordenació de les actives al principi
de la llista (no totes les actives són ``igual'' d'actives).
% section Context Químic (end)

\section{Procediment informàtic} % (fold)
\label{sec:Procediment informatic}

Des de el punt de vista estrictament informàtic, el problema es pot descriure de
la següent manera:

Tenim una entrada de dades d'un conjunt de molècules (amb un identificador
únic) amb els seus 22 valors associats a cadascuna de les sondes escollides, i una
llista amb les molècules actives (els identificadors).

Utilitzem un algoritme evolutiu, per trobar els 22 valors (ponderacions) als que
multiplicar cadascun dels potencials, que fan que obtinguem una ordenació de les
molècules que classifica les actives al principi.

El procés però, no és tant directe com això, ja que les dades s'han de
pretractar, per a treure molècules errònies, o bé triar quines de les molècules
volem que continuïn el procés i quines no (hi ha molècules que son molt similars
entre elles, i no les volem, ja que podrien decantar (bias) l'algoritme genètic cap al
sobreentrenament al seu favor, quan en realitat pertanyen al mateix grup de
molècules.  S'han provat diferents tècniques d'agrupament (clustering), però no ens hem
quedat amb cap , perquè no ens han donat resultats millors amb cap de les
tècniques que s'han usat (K-means).

Una vegada fet el nucli, la interfície amb l'usuari final també s'ha hagut
de preparar separadament del algoritme genètic, ja que el nostre usuari,
prefereix un entorn amigable (web, GUI, e-mails, excel) abans que entorns més
austers (però configurables i scriptables) com pot ser una simple línia de
comandes.  

% subsubsection subsubsection name (end)
% section inf (end)
\subsection{Interfície} % (fold)
\label{sub:Interficie}

Per a la interfície amb l'usuari, s'ha escollit una interfície web, que executarà
l'usuari des de una web corporativa, amb accés restringit i controlat amb
Autenticació.  Això ens proporciona informació de quin usuari executa cadascun
dels càlculs, i així podem personalitzar la presentació, segons preferències de
cadascun.  Utilitzant la web corporativa, ens estalviem haver de gestionar els
permisos que té cada usuari, ja que la interfície que se li presenta, és
adequada per als seus permisos i les seves tasques a realitzar.

Les dades que entra un usuari són 3 llistes de molècules:

\begin{itemize}
	\item \textbf{Llista d'actives}.  Són les molècules de referència que l'usuari sap
	que tenen activitat positiva davant d'una diana concreta.
	\item \textbf{Llista d'inactives}.  Molècules que l'usuari sap que són inactives en
	aquest mateixa diana.
	\item \textbf{Llista d'esquers}.  Conjunt de molècules que l'usuari posa ``per
	omplir'', sabent que son inactives també, però amb certes propietats que ens interessa provar en
	l'experiment.   Per al nostre problema, les tractem exactament igual que les inactives.

\end{itemize}

A part de les llistes de molècules, l'usuari també entra els paràmetres $\alpha$,
RieMax, i els percentatges de molècules amb els que vol provar l'experiment.  Es
deixa la opció de no fer participar totes les molècules en l'experiment deixant 
un conjunt de molècules fora, per després avaluar i validar les dades obtingudes
(l'usuari pot fer manualment 10 fold validation, etc\dots).  Més endavant en 
\ref{sub:sobreentrenament} s'explicarà el sistema de tests i validació.

Per facilitar la usabilitat, el programa proporciona sempre uns paràmetres
estimats per defecte, en funció de les característiques de les llistes que hagi
entrat l'usuari. 
%XXX : Explicar alpha?

% subsection Interfície (end)
\subsection{Preparació de dades} % (fold)
\label{sub:preparacio de dades}
Una molècula es pot trobar en la natura en diverses formes.  Les classificacions
es divideixen en isomers i conformacions.  Una molècula pot tenir diversos
isomers, i cada isomer es pot trobar en  diverses conformacions.

És a dir, que per un nom (que serveix d'identificador), en la natura existeixen
diverses estructures, que comparteixen nom, i elements, però poden estar
organitzats de forma diferent en l'espai. Aquestes organitzacions són
simètriques en l'espai 3D, donant lloc a molècules similars, però que en l'espai
3D, no es superposen de la mateixa forma.  Les conformacions, en canvi, són
variacions de la posició dels àtoms en l'espai, però mantenint els enllaços
entre àtoms. En les conformacions, el que canvia és l'obertura en els angles
rotables de la molècula.  Per passar d'un estereoisomer a un altre, s'han de
trencar enllaços, i tornar-se a formar.  En les conformacions no passa això, i
es pot passar d'una a una altra, només canviant els angles dels enllaços i la
seva flexibilitat. 

Donat un conjunt de molècules que volem utilitzar, hem de saber quina de les
conformacions triarem per a cada molècula.  Per a fer la \texttt{explosió} de
combinacions, s'utilitza un software especific, que fa la combinatòria i genera
les possibles variacions sobre una molècula donada.  Un cop feta aquesta
explosió de combinacions, tenim diverses entrades per a cadascuna de les
molècules inicials.  Les molècules que sabem que són actives, sabem que ho són,
però no sabem quina conformació i isomer és el que la fa activa.  És per això,
que en el llistat d'actives, tenim només una entrada per a cada família de
molècules actives, tot i que en la taula de tanimotos, aquesta molècula estarà
representada en diverses entrades. 

Durant la execució del programa, el que fem, és ordenar la llista de tanimotos,
amb molècules ``repetides'', i al moment de fer la puntuació de la llista
ordenada, ens quedem només amb la millor conformació de cada família.

\subsubsection{Procés de preparació} % (fold)
\label{ssub:Proces de preparacio}

Després que l'usuari entri els paràmetres, la web llança una aplicació en Perl,
que fa la preparació de les dades, i és la que llança l'algorisme evolutiu.  El
primer que fa és, recuperar les taules, d'una base de dades (la web emmagatzema
les llistes a una BBDD MySql).

Com s'ha explicat anteriorment, per a fer les validacions, aïllem una part del
conjunt de molècules del experiment per a fer validacions a posteriori, i
assegurar-nos que no hi ha hagut sobreentrenament.

El primer pas que fem és doncs, separar els tres conjunts de molècules, en 3
subgrups, ajustant-nos als paràmetres desitjats per l'usuari.  Per a fer les
validacions, el percentatge de molècules actives e inactives, hauria de
mantenir-se en cadascuna dels tres subgrups. No ens serveix un algoritme que
deixi lloc a la incertesa (encara que en mitja funcioni), com podria ser, treure
números aleatoris entre [0,1) i en funció d'on estigui (separem el segment [0,1)
en tres trossos anteriorment ) colocar-los en un o altre grup, sinó que calculem
el percentatge d'actives respecte al de inactives, i anem omplint els grups fins
a cobrir el llindar.  Això, que pot semblar un detall d'implementació
``menyspreable'', no ho és, ja que quan disposem de poques dades (sobretot en
les actives), deixar lloc al atzar pot provocar canvis dràstics (i tràgics) en
els resultats finals.

%Posar implementacions de Agafar els números aleatoris

El segon pas és fer l'explosió de combinacions de molècules possibles (isomers i
conformacions).

A un conjunt de molècules, l'hi hem de trobar tots els isomers i les
conformacions diferents en les que es poden trobar a la natura, és per això que
primer, donada una base de dades de molècules diferents, hem de generar totes
les conformacions possibles de cada molècula.  Aquest procés es realitza
mitjançant un programa ja existent especialitzat en trobar isomers i conformacions,
analitzant enllaços rotables vs no-rotables, etc.

Al generar els diferents isomers i conformacions, afegim identificadors a les
molècules, per saber de quina molècula inicial provenien però també saber
exactament quin isomer-conformació és.  Així, si d'una molècula A, generem:

\begin{verbatim}
A_i001_c001
A_i001_c002
A_i001_c003
A_i002_c001
A_i002_c002
A_i002_c003
... 
\end{verbatim}


Aquí ens sorgeix un possible problema.  Al fer la explosió de combinacions, ens
trobem que les bases de dades, ja no estan balancejades amb els percentatges tal
i com estaven abans, sinó que en funció de les variacions que tinguin les
molècules que han entrat en cada grup (entrenament, test i validació), podem
trobar un conjunt molt més poblat del que ens esperaríem, i que varii també el
seu percentatge intern de actives/inactives. Per exemple, la molècula A, pot
tenir 6 ``descendents'', i en canvi, la molècula B pot tenir-ne només 2.

Després de consultar amb experts químics, s'ha decidit que això no influiria
negativament en els resultats finals, ja que si una molècula és més versàtil que
una altra, això mateix és un tret propi de la molècula, i està bé que es vegi
potenciada i així, tingui més participació en la llista on pertany.

Una vegada tenim les 6 llistes separades (normalment treballem amb 80\% de
conjunt d'entrenament, un 10\% de test i un 10\% de validació, i per cada una
fem una llista d'actives i una de inactives per a cada grup),  hem de filtrar la
taula d'actives, per tal que no hi hagi els  isomer-conformacions de cada
molècula, sinó que aparegui només una vegada el nom genèric de les molècules
actives.  Això ho fem perquè quan sabem que una molècula és activa, sabem que ho
és la ``família'' de molècules però per una banda, només ho serà en una de les
conformacions i per altra, no tenim informació de quina és aquesta.  És per això
que quan després fem els matchings, els fem només amb la part genèrica de cada
molècula.

%PUNT

% subsubsection Procés de preparació (end)

En aquest punt, ja es disposen de totes les dades tal i com les volem per a
executar l'algorisme genètic.  El procés intern de l'algorisme genètic, i els
seus paràmetres en detall s'explicaran en la secció pertinent ,
\ref{sub:Algoritme genetic}.  En el cas que l'usuari hagi configurat la execució
per a fer-se amb test i validació, la execució només es fa utilitzant com a
dades el conjunt d'entrenament, deixant les taules de test i validació per a
un procés posterior.

L'algorisme, dóna com a sortida les diferents poblacions que han anat apareixent
al llarg de les diferents generacions.  Així es disposa de dades per a saber com
ha estat el procés evolutiu (per exemple ens permet fer desviacions típiques
sobre les generacions per a saber la convergència) , i ens proporciona eines per
a decidir si podem utilitzar menys generacions per a aconseguir resultats
similars.

Una vegada tenim les ponderacions que han anat apareixent, parsegem aquestes
dades i n'extraiem els millors individus de cada generació.  Aquests individus
ens serveixen per diverses coses:

\begin{itemize}
	\item Poder graficar d'una manera simple la evolució de l'entrenament
	\item Reduir el volum de dades ``útils''.
	\item El millor individu de la última generació serà el que agafarem com a
	resultat final de la aplicació
\end{itemize}

Si l'usuari ha configurat el procés per a utilitzar test i validació, en
aquest moment, enfrontem les millors ponderacions de cada generació amb les
taules de test i de validació (per separat).  Aquest procés no implica cap
algorisme genètic, però s'utilitza \textbf{exactament} la mateixa funció que en
l'algorisme genètic (el mateix .h i .cpp).  Això es fa perquè les funcions de
fitness han anat canviat al llarg del temps, afegint petites modificacions sobre
la inicial, i d'aquesta manera, assegurem la consistència entre les dades.

Una vegada tenim els BedRocs que donen cadascuna de les millors ponderacions
(segons l'algorisme genètic en el conjunt d'entrenament), i els seus BedRocs
enfrontades als conjunts de test i validació (que no s'han utilitzat per al
procés evolutiu), tenim indicadors sobre si s'està sobreentrenant o no el procés
d'optimització.

Amb aquestes dades, l'usuari ja disposa de tota la informació que necessita.
Aquesta informació, se li presenta a través de la web (quan acaba el procés se'l
pot avisar amb un mail), o directament al correu electrònic.  Recordem que la
informació sobre l'usuari la disposem des de el moment que s'autentifica a la web
(procés anterior a \texttt{Pholus} en si).

La informació de com vol cada usuari rebre les dades, i els seus correus
electrònics, es reben per paràmetre en la execució del programa i, per tant, no
necessitem fer la cerca nosaltres a la base de dades d'usuaris.


% paragraph paragraph name (end)
% ?????? ELIMINAR
%Una cop les tenim generades, hem de quedar-nos amb la conformació que millors
%resultats dóna en aquest problema.  Per fer això, tenim un seguit de programes
%de tractament de dades, que ens permeten prepararles d'acord amb les nostres
%necessitats.

% subsection preparació de dades (end)
\subsection{Algoritme genètic} % (fold)
\label{sub:Algoritme genetic}

Els operadors usats en aquest algoritme genètic són dels més clàssics ja que
donat el problema, tan sols hi ha necessitat d'aplicar operadors ``bàsics'' als
individus.  Com s'ha explicat anteriorment, no s'ha volgut potenciar la
dependència entre els diferents gens dels individus, és a dir, que suposem que
no hi ha epistàcia entre els diferents gens.  És per això que, per exemple, els
creuaments tallen un cromosoma per un punt aleatori, i barregen el trossos de
dos cromosomes per a crear-ne de nous sense tenir en compte en quin punt tallen,
o quins veïns hi ha en el punt de tall.

Tot seguit s'especifiquen els paràmetres i implementacions utilitzades en aquest
programa.

\subsubsection{Individu (Cromosoma)}
\label{ssub:individu (cromosoma)}

En aquest algoritme genètic, els individus són les ponderacions corresponents a
cadascun dels potencials.  Cada individu de la població és un conjunt de 22 valors de
coma flotant (de doble precisió) que es correspon a cadascun dels 22 indicadors
(potencials),  donat que volem saber quines rellevàncies tenen els indicadors, però
confiem que no tenen cap relació un amb el següent, hem decidit no utilitzar cap
representació que tingui en compte l'ordre, ni que afavoreixi la dependència
dels gens. 

Essent valors en coma flotant, el rang que poden tenir cadascun, és massa gran
per a les nostres necessitats, donant massa llibertat al algoritme genètic per
ponderar massa a uns valors, o simplement ponderant-los alguns en valors molt alts
i fent menyspreable molts dels 22 potencials.  Aquestes solucions normalment ens
porten a resultats sobreentrenats i, és clar, no ens interessa.

Com que una ponderació competeix contra altres ponderacions, i la funció de
fitness és una funció additiva, donar un rang tant gran de possibles valors
provoca una tendència a elevar els valors de les ponderacions, obligant a que
després del càlcul es normalitzessin per a tractar amb valors més homogenis.

S'han fet proves d'acotar els valors possibles entre 0 i $Inf$, però si
permetem valors negatius, l'algorisme evolutiu pot jugar amb fer ponderar
negativament un tipus de potencial, donant més flexibilitat al algoritme
evolutiu per trobar una bona ponderació.  Si el mínim valor que pogués assignar
fos 0, simplement eliminaria un map si no té cap rellevància però d'aquesta
manera li permetem penalitzar un indicador.

Donar de marge de $-Inf$ a $Inf$, era problemàtic en tant que l'algorisme
evolutiu acaba donant molta rellevància a uns quants (pocs) potencials, i
comparativament molt poca a la majoria, donant poca riquesa a la ponderació i
tendint a sobreentrenar-se per al conjunt de dades que li entrem, però sense
donar resultats extrapolables a altres conjunts de dades.

La següent versió, va ser deixar posar valors entre [-1,1] , però tals que la
suma de tots fóra 1.  Els resultats tampoc van ser concloents (a part que tampoc
tenia molt de sentit lògic més que el de acotar que tots els individus
estiguessin dins d'uns marges).

Al final, s'ha adoptat donar un rang de [-1,1], però sense límit en la suma total
dels valors ja que així acotem els valors i també els hi deixem tenir valors
negatius, donant més versatilitat al algorisme, que així és capaç de trobar
relacions inverses d'algunes ponderacions.



\subsubsection{Inicialització} % (fold)
\label{ssub:Inicialitzacio}
Com s'ha explicat en \ref{ssub:IInicialitzacio}, la inicialització dels individus és totalment
aleatòria, amb números en coma flotant entre -1 i 1.  L'algorisme genètic no ens
imposa cap altra restricció, ja que en totes les posicions son vàlids els
mateixos valors (dins del mateix rang), i aquests valors, seran usats únicament
com a dades (valors als que multiplicar els potencials).  Al no tenir cap
significat sintàctic (al contrari que en GP, i fins a cert punt en GEP), podem
deixar la inicialització al atzar totalment.
% subsubsection Inicialització (end)

\subsubsection{Mutacions} % (fold)
\label{ssub:Mutacions}

S'apliquen mutacions en un 0.1\% dels individus una vegada fet el creuament.
Les mutacions en aquesta aplicació consisteixen en modificar una ponderació per
una altra (al·lel).  La única restricció és que es mantingui dins dels marges
[-1,+1] .  

Aplicant aquesta mutació, mantenim la diversitat en la població i anem
introduint sempre material genètic nou.  La mutació, juntament amb els
creuaments són la font principal de la variació genètica, i en aquest cas en
particular, la mutació és l'únic operador que introdueix material genètic nou.

El valor de 0.1\% s'ha utilitzat ja que és un valor estàndard, i les variacions
que hem aplicat a posteriori sobre aquest valor no han aportat millores
objectives a les solucions.

Si ens trobéssim amb problemes de convergència prematura, un dels ``trucs''
utilitzats és augmentar la probabilitat de mutació.  Com que no ens hem trobat
amb aquest tipus de problemes, el valor de 0.1 s'ha deixat com a bo.
% subsubsection Mutacions (end)

\subsubsection{Selecció} % (fold)
\label{ssub:Seleccio}
El procés de sel·lecció de candidats es segueix utilitzant un Torneig
Determinista de mida 2, és a dir, s'escullen parelles d'individus
aleatòriament i enfrontem un individu amb l'altre. Del torneig surt ``viu'' el
que millor fitness té.
% subsubsection Selecció (end)

\subsubsection{Crossover} % (fold)
\label{ssub:Crossover}

Pel creuament s'ha provat un creuament per un punt, i el creuament per dos
punts, donant millors resultats el creuament en tant sols un punt.  

Donats dos individus (els que han estat sel·leccionats en el procés de
sel·lecció per a reproduir-se , amb una probabilitat d'un 0.85 es fa creuament i
els fills són tan sols una partició formada a partir dels 2 pares, amb un punt
de tall aleatori.  Donat que no hi ha cap relació entre els diferents indexos
(estan ordenats arbitràriament) no ens hem de preocupar de partir el cromosoma
per lloc ``delicat''. 

Així doncs, el que es busca és interpolar les qualitats de dos individus ben
adaptats, per a crear uns descendents amb propietats similars.  És d'esperar que
si un individu té bon fitness, les ponderacions donades als seus indicadors
siguin bastant encertades.  Llavors, en interpolar una parella de individus,
suposem que el descendent també tindrà un fitness bo, i això farà que a mesura
que passen les generacions, la població tendeixi a millorar (en mitja).

El creuament per dos punts no ha donat millors resultats que el creuament fet
per un únic punt, i s'ha decidit quedar-se amb el creuament per un sol punt.
% subsubsection crossover (end)

\subsubsection{Fitness} % (fold)
\label{ssub:PFitness}
En aquest problema, la funció que ens indica com de bo és un individu (funció
\texttt{fitness}) és el resultat d'avaluar la ordenació que dóna la ponderació
indicada per l'individu, respecte els nostres coneixements de activitat. Aquesta
avaluació la fem mitjançant un dels diferents algoritmes d'avaluació d'ordenacions.

%XXX : enchufar bedroc, ROC, tanimotos, i tota la merda

És així, una funció que pondera ordenacions.  Per tant, la funció té un cost
elevat per a ser cridada per cada avaluació d'un individu.  S'han utilitzat
algunes tècniques d'optimització per a evitar recalcular ponderacions ja fetes,
com per exemple, catxejar els resultats (memoize).  Com que l'algorisme
s'executa ``d'una sola tacada'', la caché pot ser totalment mapejada a memòria,
sense haver de bolcar-la en cap moment a disc.  Això és de vital importància, ja
que segons com haguéssim d'emmagatzemar les dades en disc, el cost d'accés a les
dades seria superior al de recalcular. 

La memoització, és una tècnica semblant a la programació dinàmica, la qual ens
permet estalviar càlculs en els casos d'haver de fer el mateix càlcul moltes
vegades.  A diferència de la programació dinàmica, no es necessita una taula de
2 dimensions on guardar els resultats parcials, sinó que els resultats de
anteriors càlculs es guarden en un diccionari local a la funció que volem
memoitzar \cite{MJD05}. 

Per a utilitzar la memoització tal i com es va definir en els inicis
(scheme), el llenguatge en el que ho implementem ha de tenir ``closures''
(tancaments).  Com que C++ no les té (això canviarà probablement amb
\texttt{C++0x})
i aprofitant que les llibreries utilitzades utilitzen ja una emulació de
closures anomenat functors, hem pogut guardar l'estat de les funcions sense
molta dificultat. 

Functors és la tècnica utilitzada en c++ per emular una funció amb estat privat,
que es manté de crida a crida d'aquesta.  Per a fer això es crea un objecte, amb
l'operador ``\textbf{()}'' sobrecarregat.  D'aquesta manera, podem simular que l'objecte
creat, és en realitat una funció, amb la particularitat que la hem de crear
anteriorment amb un \texttt{new}.  Segueix un exemple en pseudo-c++.

%\lstlistoflistings

\lstset{language=c++,
	tabsize=2}
\lstset{commentstyle=\textit}

\begin{lstlisting}[frame=trbl]{}
class Funcio{
private:
	map<int,double> dict;
public:
	Funcio(){};
	~Funcio(){};
	operator()(int param1){
		if( dict.exist(param1)){
			return dict[param1];
		}
		double resultat;
		// calcular i omplir resultat ...

		dict[param1]=resultat;
		return resultat;
	}
}
\end{lstlisting}


Per a calcular la qualitat d'una ordenació, hi ha diverses maneres de fer-ho.

\begin{itemize}
	\item Roc
	\item BedRoc
	\item Enrichment Factor
	\item ...
\end{itemize}


En qualsevol d'aquests procediments, es tracta d'avaluar com està de ben ordenada una llista, en funció d'unes regles.

Posarem un exemple per tal de fer més fàcil la comprensió de la funció de
fitness.

Suposem una taula amb els identificadors i tanimotos d'un seguit de molècules,
unes d'elles actives i altres inactives (esquers o decoys).


 % theme=Berlin;caption_top=1;caption=Exemple tanimotos
 % id & indicador1 & indicador2
 % m1\\_i001\\_c001 & 0.4 & 2
 % m1\\_i001\\_c002 & 0.7 & 63
 % m2\\_i001\\_c001 & 0.2 & 9
 % m3\\_i001\\_c001 & 0.1 & 0

\begin{table}
\centering
\begin{tabular}{|l|r|r|}
\hline
\multicolumn{1}{|c|}{\textbf{id }} & \multicolumn{1}{c|}{\textbf{ indicador1 }} & \multicolumn{1}{c|}{\textbf{ indicador2}} \\
\hline
\hline
m1\_i001\_c001 & 0.4 & 2  \\
m1\_i001\_c002 & 0.7 & 63 \\
m2\_i001\_c001 & 0.2 & 9  \\
m3\_i001\_c001 & 0.1 & 0  \\
\hline
\end{tabular}
\caption{Exemple tanimotos}
\end{table}

De totes elles, sabem que les actives son, per exemple m1 i m2, però no sabem
en quina de les conformacions i estereoisomer ho son.  Per tant, agafem només el
nom genèric, i cada cop escollirem la millor de cada família en funció de quina
quedi millor posicionada.

% subsubsection Fitness (end)


\subsection{sobreentrenament} % (fold)
\label{sub:sobreentrenament}

Un dels problemes que comporta la utilització d'algoritmes evolutius és
l'anomenat sobreentrenament.  El sobreentrenament és l'efecte que es dóna quan
utilitzem un conjunt de dades per entrenar un programa, i l'utilitzem tantes
vegades, que la solució obtinguda és molt bona pel conjunt de dades amb el qual
ha estat entrenat, però al aplicar la solució obtinguda en altres dades, els
resultats obtinguts són molt pitjors als esperats.  Aquest és un problema
relativament comú a la majoria d'algoritmes pertanyents a la Intel·ligència
artificial, com poden ser les xarxes neuronals, els algoritmes evolutius o els
algoritmes de \texttt{Raonament basat en casos}.

Això es pot donar per diverses raons i s'han fet molts estudis sobre la
matèria, ja que és un dels problemes més importants que se'ls critica als
algoritmes evolutius, però un dels motius més freqüents és quan
disposem de poques dades en el nostre conjunt d'entrenament.  Si les dades
d'entrenament són un conjunt molt petit, l'algoritme genètic, prepara una
solució ``a mida'', donant-nos molt bons resultats en les nostres dades, perquè
``estudia'' els casos del conjunt de entrenament un per un, creant solucions
ad-hoc, no aplicables a altres conjunts de dades.

Per tenir controlat aquest sobreentrenament, s'ha aplicat una tècnica basada en
``leave one out'' on fem l'entrenament amb un percentatge determinat de les
dades, 
% 10 cross validation?

\begin{itemize}
	\item Pq no es sobreentreni, conjunt d'entrenament, conjunt de test i conjunt
		de validació.
	\item 80 10 10, es fa sobre molècules i després es deixen passar totes les
		conformacions d'aquestes molècules, fent que les dades finals no siguin 80 10 10
		, però això es correcte perquè la flexibilitat d'una molècula es part de la seva
		'qualitat'.
	\item aquestes ponderacions que ens dona el algoritme genètic, es
		\texttt{loguegen} i es manté un històric d'elles, per saber quina és la mitja
		de la població en cada iteració (generació), i la desviació típica.  El que
		és normal és que la mitja sigui més propera cada cop al màxim, i que la
		desviació típica sigui cada cop menor.
	\item Una vegada fet l'entrenament, ``enfrontem'' els millors individus de
	cada generació als elements dels nostres conjunts de test i de validació,
	tenint així un conjunt de punts quantitatius (recordem que el fitness que
	avaluàvem era un valor quantitatiu).
	\item Si grafiquem els valors que hem obtingut en un eix de 2D, amb 3
	funcions, representant l'evolució del fitness en el conjunt d'entrenament, de
	test i de validació, esperem trobar una figura que sigui (més o menys) així:
	%FIGURA APROXIMADA
\end{itemize}
 
Tot seguit es mostren els resultats obtinguts, i s'explicarà la interpretació
que se'ls hi ha donat.

% subsection sobreentrenament (end)

% section Al (end)

\section{Resultats} % (fold)
\label{sec:Resultats}

\subsection{Testeig} % (fold)
\label{sub:Testeig}

Una vegada testejat el programa ``a ull'', i quan assegurem que el sistema
funciona tal i com estava previst en els requeriments, s'ha de testejar que
Pholus, no tan sols funcioni bé, sinó que solucioni el problema químic que se li
demana.

Per a testejar-l'ho ho hem fet en un experiment on busquem una molècula que
bloqueja l'acció d'una proteïna de la cèl·lula.

La validació s'ha fet executant \emph{Pholus} deu vegades, i traient
dades detallades sobre el valor del fitness del millor element en cada
generació, i graficant els millors fitness de cada generació.

%En aquest problema, teníem 68 molècules actives, 
En la taula \ref{qrpholustest} expliquem les característiques principals d'aquest problema.

 % theme=Berlin;caption=Pholus test
 % Molècules actives & 64
 % Molècules inactives & 2653
 % alpha & 20
 % repeticions & 10
 % generacions per execució & 120
 % probabilitat de creuament & 0.8
 % probabilitat de mutació & 0.1

\begin{table}
\centering
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}{\textbf{Molècules actives }} & \multicolumn{1}{c|}{\textbf{ 64}} \\
\hline
\hline
Molècules inactives      & 2653 \\
alpha                     & 20   \\
repeticions               & 10   \\
generacions per execució & 120  \\
probabilitat de creuament & 0.8  \\
probabilitat de mutació  & 0.1  \\
\hline
\end{tabular}
\caption{Pholus test} \label{qrpholustest}
\end{table}

S'ha de tenir en compte les dades d'aquest experiment, per a donar una
interpretació correcte als resultats.

En les següents gràfiques, es mostren les dades de les deu repeticions que s'han
fet de la execució.  A priori, les dades que podríem esperar, son gràfiques com
la Figura \ref{fig:sobreent}.  La línia amb forma logarítmica, és
el fitness del conjunt amb el què entrenem el algoritme genètic.  Aquest, serà
estrictament creixent, ja que utilitzem elitisme, i el creixement del fitness té
forma logarítmica.  El conjunt de test, serà el que utilitzarem per a saber el
punt on l'algorisme genètic comença a sobreentrenar la solució pel conjunt
d'entrenament.  Al no fer participar aquest conjunt més que en aquesta gràfica, podem
saber quin es el moment on, tot i que el fitness pel conjunt d'entrenament millori,
comencem a empitjorar el fitness per al conjunt test.  En aquest punt màxim de
la gràfica de test, és on agafarem la solució.

Si agafem com a valor millor individu el que tenim en el punt on maximitza el
resultat del conjunt de test, podria ser que el que estiguem fent sigui
sobreentrenar l'algoritme per al conjunt de test.  Es per això que tenim un
altre 10\% de les dades totals en el conjunt que anomenem \emph{de validació}. 

Aquest conjunt de dades ens serveix per a assegurar que no estem cometent el
mateix error del sobreentrenament però aquesta vegada, maximitzant el conjunt de
test.  

En la figura \ref{fig:sobreent} veiem un esbós del que esperem que surti, si és que s'està
sobreentrenant. Sabrem si sobreentrenem la solució en funció del grau de similitud entre els nostres
resultats i la figura \ref{fig:sobreent}
% subsection Testeig (end)

\begin{figure}[h]
	\begin{center}
		\includegraphics{pholus/sobreentrenament.jpg}
	\end{center}
	\caption{Resultats esperats en cas de sobreentrenament}
	\label{fig:sobreent}
\end{figure}

\subsection{Anàlisi de Resultats} % (fold)
\label{sub:Analisi de Resultats}

Els resultats obtinguts, han estat satisfactoris, i hem deduït que no hi ha
hagut sobreentrenament, ja que en les deu execucions, no s'observa el patró que
hem comentat del sobreentrenament.

De les observacions que hem fet, podem concloure que no hi ha sobreentrenament,
ja que , en general les gràfiques de testing i validació, són bastant estables,
i la validació no cau a partir d'arribar al màxim de testing (Figures \ref{fig:pholusResult1},
\ref{fig:pholusResult2}, \ref{fig:pholusResult3}, \ref{fig:pholusResult4}, \ref{fig:pholusResult5},
\ref{fig:pholusResult6}, \ref{fig:pholusResult7}, \ref{fig:pholusResult8}, \ref{fig:pholusResult9},
\ref{fig:pholusResult10}).

En gairebé tots els casos observem que no el testing si que té el màxim en un
punt cap a les 60-80 generacions, però la davallada de després tampoc és molt
pronunciada, com per entendre que s'està donant un cas de sobreentrenament.

Un factor a tenir en compte és el número tant petit de molècules actives, que fa
que al dividir-les en 3 grups, algun dels conjunts de dades, es quedin amb molt
poques molècules, i al llarg de la execució del AE, un petit canvi en la
ordenació, provoca un canvi alt en el fitness del individuu, ja que canvia el
Bedroc molt ràpidament.  Un conjunt amb més molècules actives, com pot ser el
d'entrenament, normalment és molt més consistent i els canvis en la ordenació,
provoquen canvis en el fitness més graduals.

Un altre factor que hem de tenir en compte per a avaluar aquests resultats, és
que les molècules actives, no són totes igual de difícils de classificar, sinó
que poden agrupar-se en clústers de similitud entre elles.  Amb aquests grups
podem classificar les 68 molècules en 11 clústers o grups,  Al agafar un 10\% de
les dades, queden molt poques molècules en cada conjunt, i depenent de la
agrupació amb la que quedin aquestes actives, poden fer que, per exemple, com es
veu en la Taula \ref{fig:pholusResult1} i \ref{fig:pholusResult4}

\begin{figure}[h] \begin{center}
\includegraphics[scale=0.75]{pholus/pholus1.png}
\end{center}
\caption{càlcul 1}
\label{fig:pholusResult1}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus2.png}
\end{center}
\caption{càlcul 2}
\label{fig:pholusResult2}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus3.png}
\end{center}
\caption{càlcul 3}
\label{fig:pholusResult3}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus4.png}
\end{center}
\caption{càlcul 4}
\label{fig:pholusResult4}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus5.png}
\end{center}
\caption{càlcul 5}
\label{fig:pholusResult5}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus6.png}
\end{center}
\caption{càlcul 6}
\label{fig:pholusResult6}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus7.png}
\end{center}
\caption{càlcul 7}
\label{fig:pholusResult7}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus8.png}
\end{center}
\caption{càlcul 8}
\label{fig:pholusResult8}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus9.png}
\end{center}
\caption{càlcul 9}
\label{fig:pholusResult9}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.75]{pholus/pholus10.png}
\end{center}
\caption{càlcul 10}
\label{fig:pholusResult10}
\end{figure}

% subsection Anàlisi de Resultats (end)
% section Resultats (end)
\section{Conclusions i treball futur} % (fold)
\label{sec:PConclusions i treball futur}
En aquest projecte hem desenvolupat exitosament un programari que ha permès ser
més eficients en un procés que ja existia, però nosaltres l'hem millorat, no
només en sentit d'aproximació química, sinó aprofitant-nos de les avantatges que
ens ofereixen els algorismes genètics, permetent-nos explorar un espai de
possibles solucions immens, en un temps raonable (entre 2 i 8 hores segons la
mida del problema).

La exploració d'aquest problema ens ha servit per aprendre una mica sobre
les unions entre lligands i dianes i també les maneres de agrupar molècules per
famílies, però sobretot ha servit per a provar que els algorismes genètics poden
donar solucions reals i viables a problemes que són molt difícils de solucionar
amb altres tècniques.

Pholus, però no és un projecte tancat, i de fet, ja s'ha ampliat i millorat
respecte al que es presenta aquí, amb una interfície web i un sistema de mails
per a reportar la finalització dels càlculs als usuaris.

% section Conclusions i treball futur (end)
%\end{document}

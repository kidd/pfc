\documentclass[titlepage,a4paper,12pt]{book}

\usepackage[utf8]{inputenc}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{marvosym}
\usepackage{amssymb, amsmath} 
\usepackage{listings}
\usepackage{textcomp}
\usepackage[]{color}

%\lstset{
	%language=C++,
	%keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	%identifierstyle=\ttfamily,
	%commentstyle=\color[rgb]{0.133,0.545,0.133},
	%stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	%showstringspaces=false,
	%basicstyle=\small,
	%numberstyle=\footnotesize,
	%numbers=left,
	%stepnumber=1,
	%numbersep=10pt,
	%tabsize=2,
	%breaklines=true,
	%prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	%breakatwhitespace=false,
	%aboveskip={1.5\baselineskip},
  %columns=fixed,
  %upquote=true,
  %extendedchars=true,
%% frame=single,
%% backgroundcolor=\color{lbcolor},
%}

\begin{document}
\tableofcontents  %%Index

\section{Introducció} % (fold) Objectius?
	\label{sec:Introduccio}
	Tot seguit es presentará un projecte en el que s'ha utilitzat una tècnica
	molt pionera derivada de la programació genètica anomenada ``Genetic
	Expression Programming'' (GEP).  A falta d'un nom millor hem tractat el
	problema amb el nom de \texttt{GEP}.

	En aquest projecte apliquem Genetic Expression Programming per a descobrir
	fórmules analítiques a partir de resultats empírics o bé mostrejos que tenim
	a priori de característiques que tenen les molècules en funció de parametres
	de configuració de les mateixes molècules.  És a dir, per exemple, en funció
	dels angles en els punts on hi ha angles rotables, una molècula es diu que
	té un volum diferent, en tant que la seva zona d'acció canvia.  Segons com
	siguin aquests angles, la molècula pot estar ``arreplegada'' sobre si
	mateixa, donannt lloc a un volum més petit que no pas si està extesa en
	l'espai, havent-hi molt més espai entre els seus àtoms consecutius.

	Aquesta informació és necessita per a poder tractar més còmodament amb
	aquesta informació, i forma part d'un procés més complex relacionat amb XXX


% section Introducció (end)

\section{Context Químic} % (fold)
	\label{sec:Context Quimic}

\section{Procediment informàtic} % (fold)
\label{sec:Procediment informatic}

El diseny i implementació  d'aquest projecte és la que s'ha emportat més temps
proporcionalment, ja que s'ha hagut de fer molta investigació per a ajustar els
paràmetres del algorisme genètic, i per a implementar els diferents operadors.

Ens enfrontem a un problema on el cromosoma, a diferència Pholus i Chiron, no
pot ser tractat com un vector d'elements independents, ja que s'ha de mapejar un
arbre (que representa una fórmula analítica) en un vector, i un gen
\textit{i} té molta repercusió en els seus gens posteriors.

La manera clàssica d'atacar els problemes de programació genètica, és
confeccionant una representació d'un arbre en el cromosoma, en preordre,
inordre, o postordre.  Cadascuna d'aquestes implementacions suposa uns pros i
uns contres, ja sigui en la construcció, la interpretació (per a executar la
funció de fitness s'ha d'evaluar el resultat, i per tant, s'ha de reconstruir
l'arbre), o en els diferents operadors, tant el creuament com la mutació.

Com a primera aproximació, s'ha implementat un arbre en preodre, ja que facilita
molt la evaluació, una de les parts més costoses i que s'ha de fer més cops al
llarg del algoritme.

Imaginem que tenim un arbre de la següent manera:

\begin{verbatim}
+ 2 - 3 2
\end{verbatim}

Aquest arbre, que traduit a inordre és $ 2 + (3 -2) $ , pot ser calculat
construint un evaluador com una màquna de pila, on apilem els elements a mesura
que els anem trobant, i evaluem les operacions una vegada tenim els operands
suficients per a la última operació que hem apilat.

La construcció en preordre deixa les fulles al final dels subarbres, i això és
convenient en la mesura del possible, ja que per als creuaments, augmenta la
possibilitat de crear un arbre vàlid. % XXX REF a creuaments

Un dels problemes que es donen en els algorismes de programació genètica, és la
construcció d'arbres invàlids. Per exemple, suposem que fem un creuament per un
punt de tall entre dos arbres, com si fós un algorisme evolutiu clàssic.

\begin{verbatim}
+ 3 * 3 | - 4 3
- Q + * | 5 3 5
\end{verbatim}

al intercanviar els arbres, un dels 2 arbres que queden (- Q + * - 3 5) no
disposa de prous operands per a realitzar la evaluació.  Això és un cas senzill
de tots els problemes que es poden generar al fer creuaments, i és el cas en el
que utilitzem el creuament més trivial (creuament per un punt). Si utilitzéssim
creuaments més sofisticats, els casos que hem de tractar particularment per
creixen molt de pressa.  Només fent un creuament per 2 punts, es generen
moltíssims més arbres sintacticament incorrectes.

És per això que s'ha adoptat finalment per una aproximació utilitzant una
representació ideada per Cándida Ferreira (XXX bib), on per la pròpia construcció del
arbre, podem assegurar que \textbf{sempre} generarem arbres sintàcticament
vàlids.

\subsection{Interfície} % (fold)
\label{sub:Interficie}

Pel que fa al usuari, en aquest cas encara no està molt definit com utilitzarà
el programa una vegada estigui en producció, ja que segurament, GEP es farà
servir com a complement per a Helios 2.0, però les entrades al programa son
clares:

Es disposa de resultats empírics (o bé per laboratori o bé utilitzant softwares
de simulació) sobre, per exemple, el volum d'una molècula en funció dels angles
dels seus enllaços rotables.

En un cas així, les dades d'entrada són els diferents angles i els volums
obtinguts, i el que es demana a la aplicació, és que a partir d'aquestes dades,
trobi una fórmula analítica que representi (amb la major fiabilitat possible)
aquestes dades, per a poder generalitzar les dades empíriques a una fórmula
tractable matemàticament.

El programa ha d'executar-se d'una tirada, amb el que no tindrà cap component de
interactivitat, ni es necessitarà cap tipus de emmagatzematge de dades
intermitges.

La entrada, doncs, es fa a través d'un paràmetre que ens indica on estan els
resultats que coneixem, juntament amb les dades que ens porten a aquests.

Juntament amb les dades, també s'han d'entrar els diferents paràmetres referents
al algorisme genètic.  Ara per ara no està implementat, però com es veurà en
l'apartat de treballs futurs(XXX), s'ha pensat permetre a l'usuari (se'l
considera un usuari ``expert'', que coneix tant el problema, com té coneixements
d'algorismes genètics) entrar ``building blocks'' addicionals, o
activar/desactivar els que ja venen per defecte.

Això suposa un gran repte a causa de les característiques estàtiques del
llenguatge, però ja s'han estudiat algunes maneres per a poder utilitzar
tècniques que permeten ``dinamitzar'' el llenguatge (utilitzant plugins o
llenguatges de scripting acoblats (embeded) al programa c++.
% subsection Interficie (end)


\subsection{Preparació de les dades} % (fold)
\label{sub:GPreparacio de dades}

La preparació de dades necessària per a aquest projecte no té massa rellevància,
ja que disposem a priori dels conjunts de dades d'entrada i resultats.

El programa simplement agafa les dades d'uns arxius que hem tractat amb uns
petits scripts per a tenir un format realment còmode.

Per a les proves que s'han realitzat per descubrir funcions matemàtiques
conegudes, la mateixa funció s'ha implementat en la funció d'evaluació, i
simplement, s'executa amb les dades d'entrada, per a tenir el resultat a
comparar-lo amb el resultat de la formula que estem evaluant.

% subsection Preparació de les dades (end)

\subsection{Implementació} % (fold)
\label{sub:GImplementacio}

Aquest projecte ha estat el més difícil d'implementar i disenyar, ja que hem
hagut de fer un treball notable d'investigació (els primers referents en GEP
daten de 2002 XXX).

El procés general del algoritme evolutiu és, donada una llargada de cromosoma,
decidida per l'usuari en funció de la complexitat ``intuitiva'' de la formula
que es vol descubrir, i uns paràmetres de probabilitat de creuaments i
mutacions, la aplicació ha de retornar una fórmula analítica que s'apropa (o
clava) la fórmula que estem buscant.
% subsection Impl (end)

(XXX) fer una seccio dedicada a GP i GEP o posar-ho a la implementació?

\subsubsection{Arbres} % (fold)
\label{ssub:Arbres}

Com s'ha explicat en \ref{introGEP i Procinf}, en GEP, la interpretació dels
cromosomes com a arbres a l'hora d'avaluar-se, fa que necessitem poder passar
del fenotip(lineal) al genotip (arbre) amb facilitat, i aquest genotip sigui
tractable com a tal, avaluant les seves característiques en l'entorn (calculant
l'arbre) de manera còmode, ràpida i eficient.

Per això s'ha desenvolupat un conjunt de classes per a tractar amb arbres, que
ens permeten construir i avaluar aquests arbres a partir d'un cromosoma (vector
de símbols).

Aquesta estructura, s'ha programat el més flexiblement possible, deixant la
possibilitat de ser extesa en un futur, afegint nous tipus d'operacions, i amb
diferents aritats, més grans de les que hem tingut necessitat fins al moment.

Nosaltres hem tractat només amb aritats 0,1 i dos (a € {0,1,2} ) ja que els
operands tenien un màxim de aritat 2.


 % theme=Berlin;caption_top=1;caption=Relació funció-aritat
 % simbol & aritat
 % + & 2
 % - & 2
 % * & 2
 % / & 2
 % sin & 1
 % cos & 1
 % sqrt (arrel quadrada) & 1
 % terminals (x,y,z..) & 0

\begin{table}
\centering
\caption{Relació funció-aritat}
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}{\textbf{simbol }} & \multicolumn{1}{c|}{\textbf{ aritat}} \\
\hline
\hline
+                     & 2 \\
-                     & 2 \\
*                     & 2 \\
/                     & 2 \\
sin                   & 1 \\
cos                   & 1 \\
sqrt (arrel quadrada) & 1 \\
terminals (x,y,z..)   & 0 \\
\hline
\end{tabular}
\end{table}

Per a poder construir un arbre complet, i avaluar-lo, a partir d'un vector de
simbols (implementats com a caràcters, donada la manca de símbols en c++ com a
tipus bàsic), i poder-ho fer amb la màxima robustesa i flexibilitat, s'ha
implemntat una estructura amb nodes, i un arbre tipus template.

Tot seguit es mostra el diagrama de classes d'aquesta part GEP.

%figura estructura de classes

Com es pot veure en la figura anterior (XXX ref fig), s'ha implementat una
classe abstracte Node de la que ``pengen'' les diferents especialitzacions, que
son les diferents operacions que suporta GEP, o bé els terminals. Els terminals,
com és d'esperar, tenen aritat zero, i al ser evaluats, retornen el valor del
terminal en aquest moment com a resultat.  Els operadors (aritat > 0),
requereixen d'altres nodes per a calcular el seu resultat.  D'això es deriva que
en un cromosoma donat, al transformarlo a genotip, les fulles seran totes
terminals, ja que son l'únic tipus de node que poden evaluar a un valor sense
necessitat de cap altre resultat precalculat.

Al haver-se de crear nodes dinàmicament (i intensament) durant cada execució,
s'ha utilitzat un patró \emph{Factory}, per facilitar la creació de nodes amb
una sintaxis extensible, per quan es vulguin afegir operadors, i per a fer més
còmode la seva utilització.

Després de implementar-se aquesta part, hem descobert una manera tant o més
elegant de fer-se aquest procés:  Utilitzant les llibreries Boost (XXX ref), que
ofereixen, entre d'altres, funcionalitatsl pròpies de llenguatges funcionals,
com per exemple Boost::Functional, que permet la programació de c++ retornant
funcions com a valor de retorn de una funció (programació d'ordre superior).  
D'aquesta manera, encara podem delegar un pas més avall la creació de nodes, 

arbres, nodes, evaluacio, etc.
patro estrategia + factory
Parlar de BOOST::Functional
% subsubsection Arbres (end)

\subsection{Algorisme Genètic} % (fold)
\label{ssec:GAlgorisme Genetic}

\subsubsection{Individu (Cromosoma)} % (fold)
\label{ssub:Individu (Cromosoma}

Per aquest s'han utilitzat els cromosomes representats com s'ha explicat en
l'apartat \ref{issub:individus}, però no només s'han utilitzat cromosomes amb un
gen, sinó que hem seguit dues altres maneres, més sofisticades per a representar
les nostres fórmules matemàtiques.

Aquests mètodes \cite (XXX) es basen en complicar una mica més el cromosoma,
però sempre fent servir la notacio karva \ref{XXX}.

Una de les millores, és encabir més d'un gen en un cromosoma. Fent això, el que
aconseguim és evolucionar dos subarbres, que en el moment de la avaluació,
s'uneixen d'alguna manera.

Si apliquem aquesta tècnica, es facilita la creació de subarbres que conformen
el que s'anomenen ``building blocks'', o blocks constructors que representen una
petita part (però significativa) de la fórmula que es vol acabar trobant.

EXEMPLE

Una de les maneres de combinar els diferents gens és utilitzant \emph{Link
functions} o funcions d'enllaç, que son operadors que decidim a priori, i
seràn els nodes arrel de l'arbre final.

En \ref{figXXX} es mostra com s'avaluarà el cromosoma mostrat abans amb funcions
d'enllaç suma.

Aquesta millora, dona molta flexibilitat al algorisme genètic, ja que li dona
poder per a fer combinacions entre diferents cromosomes (en el creuament), només
cambiant una part del arbre, i no fent cambis molt radicals al fenotip.  Aquest
procés de linkatge està també inspirat amb els procediments de la naturalesa per
a ensamblar proteïnes a partir de components més petites.

La següent implementació i millora és construir un gen una mica diferent en un
dels extrems del cromosoma, que contingui informació codificada sobre el propi
cromosoma.  Aquest tipus de metainformació és molt valuosa, i ens permet que el
propi cromosoma sàpiga com ensamblar-se i a més, ho pugui fer d'una manera
variable, que vagi evolucionant al mateix temps que evoluciona tot el propi gen.

El caire recursiu d'aquesta millora és una de les claus del bon funcionament de
GEP, ja que permet guardar una espècie d'``estat'', que ens dona dades sobre com
organitzar la pròpia informació que conté.

La manera de codificar-se, però, és molt similar a la que ja coneixem fins ara,
i gràcies a aquesta homogenietat, no s'han de fer tractaments especifics per a
aquesta metainformació ja que es codifica també amb forma d'un arbre amb notació
Karva, que en comptes d'utilitzar els terminals com a elements d'aritat zero, el
que s'utilitza com a elements ``de finalització'' són identificadors que es
refereixen als anteriors gens o ADT.

Com tots els gens, aquest gen especial, té un head i un tail, i en el seu head
es poden utilitzar els mateixos operadors que en la resta de heads.  Tot i així,
nosaltres hem reduit el nombre d'operadors a només $+,-,*,/$, descartant
operands com el sinus, cosinus i la arrel quadrada.

Com que el número de terminals diferents que pot tenir aquest meta-gen vé
determinat per el número total de gens amb els que configurem els cromosomes (el
número de terminals serà N-1 on N és el número total de gens), el número de gens
s'ha de saber al principi de la execució del programa, i no pot ser modificat
durant la execució (també violariem tota la homoiconicitat  d'un cromosoma respecte
els altres).

Per codificar aquests ``punters'' als ADTs, utilitzem números del 0..N-2
(seguint la mateixa notació anterior).

A continuació es mostra com un cromosoma multigènic homeòtic es codifica i
s'evalua.

% subsubsection Individu (Cromosoma (end)

\subsubsection{Inicialització} % (fold)
\label{ssub:Inicialitzacio}
La població inicial, inicialitza un número $N$ de cromosomes de manera
aleatòria.  La forma en què s'han d'inicialitzar els cromosomes és barrejant en
un mateix individu operadors i terminals, durant la ``zona de operadors'', o
\emph{head}, i omplint, només amb terminals la zona restant (cua o \emph{tail}).

Recordem que per a què un arbre (fenotip) sigui correcte, el genotip només ha de
complir la condició que en la darrera part del genotip, no hi hagi operadors.
La mida de la primera part es pot calcular de la següent manera:

Per a cada problema, es tria la llargada del head $h$.  Per a aquest head, la
llargada del \emph{tail} vé donada per una funció amb entrades $h$, i la major
aritat de tots els operadors que poden apareixer en el head $n$.

\begin{math}
t =  h (n-1) + 1
\end{math}

En el nostre cas, s'han implementat tres tipus diferents de cromosomes. Cal
tenir en compte, que aquí, la notació de GEP pot fer confondre, ja que es diu
``gen'' a cada arbre que es formarà en el fenotip, i no pas a cada posició
individual en el genotip.
%provar paragraph

\begin{itemize}
	\item Unigen : En cada cromosoma, només hi ha un gen.  Això vol dir que hi
	ha un \emph{head} i un \emph{tail}. És la versió ``clàssica'', que s'ha
	explicat en \ref{XXX} (intro)
	\item Multigen-AD: Cromosoma multigen amb funcions de linkatge.
	\item Multigen homeòtic: Cromosoma multigen amb l'últim gen contenint
	informació sobre com s'organitzen els altres gens, en forma de arbre
	(notació Karva)
\end{itemize}

En funció de quina variant executem, el mòdul  d'inicialització té una relació
dels rangs del cromosoma amb col·leccions de símbols que poden anar en cada
rang.  Sabent això la inicialització es fa triant aleatòriament un símbol dins
de la col·lecció per a cada posició.

Com que per definició, els cromosomes construits en Karva notation sempre són
sintàcticament correctes no ens hem de preocupar de validar que en les
avaluacions donin errors d'aquest tipus.
% subsubsection Inicialització (end)

\subsubsection{Sel·lecció} % (fold)
\label{ssub:Seleccio}
torneig?
% subsubsection Sel·lecció (end)

\subsubsection{Creuament} % (fold)
\label{Gssub:Creuament}

Els creuaments en GEP funcionen d'una manera similar als Algorismes Genètics
clàssics, en tant que no hem de tenir present la futura traducció del genotip al
fenotip.  Entre les tres formes de creuament, s'arriba a un 0.8 de probabilitat
de creuament.

La única cosa que faria que un creuament donés lloc a un cromosoma invàlid,
sería canviar de posicions els elements que creuem a menys que movem gens
sencers.

\paragraph{Creuament per un punt} % (fold)
\label{par:Creuament per un punt}
És el creuament que ja hem vist en els Algorismes Evolutius, on es tria
aleatòriament un punt de tall per cada parella de pares, i d'allà en surten dos
cromosomes nous, que contenen informació dels dos pares, l'un tenint la primera
part del p1 i la segona del p2 i l'altre fill l'invers.  Aquesta tècnica de
recombinació ofereix molta variabilitat a l'algorisme, éssent després de la
mutació l'operador que n'aporta més.
% paragraph Creuament per Un punt (end)
\paragraph{Creuament per dos punts} % (fold)
\label{par:Creuament per dos punts}
En aquest creuament, donats dos cromosomes a creuar, es trien dos punts (quedant
cadascun d'ells dividit en tres parts), i s'intercanva la part central.
D'aquest creuament cal notar que es beneficia molt de les parts que podien
quedar ocultes en els seus progenitors, activant-les de nou.  Aquest material
genètic amagat en forma de regió no-codificadora, que s'ha anat creuant i mutant
al llarg de les generacions, pot ara prendre protagonista i ajudar (o no) a
millorar el fitness d'un element.
% paragraph Creuament per dos punts (end)
\paragraph{Creuament per recombinació de gen} % (fold)
\label{par:Creuament per recombinacio de gen}

L'últim creuament que hem aplicat exitosament és el de la recombinació de gens.
En aquest procés, es separen els gens dels dos cromosomes pares, i en el procés
de recombinació, es reordenen els gens
% paragraph Creuament per translació de gen (end)

Creuaments, arbres subarbres blablba

tipus de creuaments
% subsubsection Creuament (end)

\subsubsection{Mutacions} % (fold)
\label{Gssub:Mutacions}

Les mutacions són els operadors que proporcionen més variabilitat genètica al
algorisme, i que eviten la convergència, ajudant-nos a explorar el màxim espai
de búsqueda possible.

Igual que en el cas dels creuaments \ref{Gssub:Creuament}, també en tenim de
tres tipus, però a diferència del creuament, aquí si que hem de tenir un control
més estricte de quins símbols cambien, i a què cambien, ja que no totes les
posicions tenen un mateix conjunt de possibles valors, i hem de tenir en compte
quina posició estem tocant per a aplicar una mutació.

Les mutacions no tant sols muten un símbol, sinó que normalment muten un
conjunt de símbols consecutius o no.

\paragraph{IS} % (fold)
\label{par:IS}
Aquesta és la mutació més simple de totes, i s'ha implementat només per a
usarla en la fase de prototipatge, quan s'utilitzàven cromosomes unigen.  Donat
un cromosoma, s'escull una posició, i una llargada, normalment no superior a la
tercera part de la mida total del gen, i es ``puja'' cap a una posició anterior
en el gen.  La zona font pot ser qualsevol posició del gen, però la zona destí,
té com a restricció no poder començar en l'arrel del arbre (primera posició en
el cromosoma).  Aquesta restricció té la seva explicació en què si tenim un
cromosoma amb un sol gen, i pujem un terminal a la posició arrel, el que fem és
anular tot l'arbre, ja que els terminals tenen aritat zero.

XXX imatge d'un cromosoma ``capat''.
% paragraph IS (end)

\paragraph{RIS} % (fold)
\label{par:RIS}
En els cromosomes multigen, aquest no és un problema, ja que eliminant un sol
gen no eliminarem la flexibilitat del cromosoma complet, ja que probablement hi
haurà alguna altra part en un altre gen, que continuarà éssent funcional.  En el
cas dels multigen homeòtics, desactivem aquest creuament per al meta-gen.
% paragraph RIS (end)

\paragraph{Translació de gen} % (fold)
\label{par:Translacio de gen}

Aquesta mutació consisteix, com el seu nom sugereix, en moure un dels ADTs a una
altra posició.  Si les relacions entre gens estan en el gen especial (que hem
anomenat meta-gen), en cambiar dos gens de posició, la estructura del arbre
construit per la part de l'arrel es mantindrà, però els gens que actuen de
terminals en aquest meta-gen, cambiaràn, donant lloc a un fenotip totalment
diferent.  Cal notar que aquest tipus de mutació, només es pot aplicar si
utilitzem individuus multigen, i que en el cas dels multigen homeòtics, no podem
fer participar el meta-gen en aquestes traslacions, ja que els seus terminals no
son de la mateixa classe que els de la resta de gens.  La possibilitat de
simplement intercanviar els identificadors en el meta-gen, tampoc serveix ja
que, tot i donar el mateix resultat (al menys en un principi), varia el
contingut del meta-gen, fent que varii la seva descendència (si es que en té) de
la que donaria lloc amb l'altre procediment.

% paragraph Translació de gen (end)
TRans

es mante la simplicitat gracies a karva notation\ldots

transp
repla

% subsubsection Mutacions (end)
% section Algorisme Genètic (end)

% section Procediment informàtic (end)
    %Introducció
    %Context Químic
    %Procediment informàtic
    %+ Algoritme Genètic
    %+  Individu (Cromosoma)
    %+  Crossover
    %+  Mutacions
    %+ Implementació
    %+  algorisme genètic
    %+  Arxius de configuració
    %+  DBIx::Class
    %+  Webservices i Soap
    %Resultats
    %+ treball futur


\end{document}

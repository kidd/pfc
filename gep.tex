\documentclass[titlepage,a4paper,12pt]{book}

\usepackage[utf8]{inputenc}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{marvosym}
\usepackage{amssymb, amsmath} 
\usepackage{listings}
\usepackage{textcomp}
\usepackage[]{color}

%\lstset{
	%language=C++,
	%keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	%identifierstyle=\ttfamily,
	%commentstyle=\color[rgb]{0.133,0.545,0.133},
	%stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
	%showstringspaces=false,
	%basicstyle=\small,
	%numberstyle=\footnotesize,
	%numbers=left,
	%stepnumber=1,
	%numbersep=10pt,
	%tabsize=2,
	%breaklines=true,
	%prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	%breakatwhitespace=false,
	%aboveskip={1.5\baselineskip},
  %columns=fixed,
  %upquote=true,
  %extendedchars=true,
%% frame=single,
%% backgroundcolor=\color{lbcolor},
%}

\begin{document}
\tableofcontents  %%Index

\section{Introducció} % (fold) Objectius?
	\label{sec:Introduccio}
	Tot seguit es presentará un projecte en el que s'ha utilitzat una tècnica
	molt pionera derivada de la programació genètica anomenada ``Genetic
	Expression Programming'' (GEP).


% section Introducció (end)

\section{Context Químic} % (fold)
	\label{sec:Context Quimic}

\section{Procediment informàtic} % (fold)
\label{sec:Procediment informatic}

El diseny i implementació  d'aquest projecte és la que s'ha emportat més temps
proporcionalment, ja que s'ha hagut de fer molta investigació per a ajustar els
paràmetres del algorisme genètic, i per a implementar els diferents operadors.

Ens enfrontem a un problema on el cromosoma, a diferència Pholus i Chiron, no
pot ser tractat com un vector d'elements independents, ja que s'ha de mapejar un
arbre (que representa una fórmula analítica) en un vector, i un gen
\textit{i} té molta repercusió en els seus gens posteriors.

La manera clàssica d'atacar els problemes de programació genètica, és
confeccionant una representació d'un arbre en el cromosoma, en preordre,
inordre, o postordre.  Cadascuna d'aquestes implementacions suposa uns pros i
uns contres, ja sigui en la construcció, la interpretació (per a executar la
funció de fitness s'ha d'evaluar el resultat, i per tant, s'ha de reconstruir
l'arbre), o en els diferents operadors, tant el creuament com la mutació.

Com a primera aproximació, s'ha implementat un arbre en preodre, ja que facilita
molt la evaluació, una de les parts més costoses i que s'ha de fer més cops al
llarg del algoritme.

Imaginem que tenim un arbre de la següent manera:

\begin{verbatim}
+ 2 - 3 2
\end{verbatim}

Aquest arbre, que traduit a inordre és $ 2 + (3 -2) $ , pot ser calculat
construint un evaluador com una màquna de pila, on apilem els elements a mesura
que els anem trobant, i evaluem les operacions una vegada tenim els operands
suficients per a la última operació que hem apilat.

La construcció en preordre deixa les fulles al final dels subarbres, i això és
convenient en la mesura del possible, ja que per als creuaments, augmenta la
possibilitat de crear un arbre vàlid. % XXX REF a creuaments

Un dels problemes que es donen en els algorismes de programació genètica, és la
construcció d'arbres invàlids. Per exemple, suposem que fem un creuament per un
punt de tall entre dos arbres, com si fós un algorisme evolutiu clàssic.

\begin{verbatim}
+ 3 * 3 | - 4 3
- Q + * | 5 3 5
\end{verbatim}

al intercanviar els arbres, un dels 2 arbres que queden (- Q + * - 3 5) no
disposa de prous operands per a realitzar la evaluació.  Això és un cas senzill
de tots els problemes que es poden generar al fer creuaments, i és el cas en el
que utilitzem el creuament més trivial (creuament per un punt). Si utilitzéssim
creuaments més sofisticats, els casos que hem de tractar particularment per
creixen molt de pressa.  Només fent un creuament per 2 punts, es generen
moltíssims més arbres sintacticament incorrectes.

És per això que s'ha adoptat finalment per una aproximació utilitzant una
representació ideada per Ferreira (XXX bib), on per la pròpia construcció del
arbre, podem assegurar que \textbf{sempre} generarem arbres sintàcticament
vàlids.

\subsection{Interfície} % (fold)
\label{sub:Interficie}

L'usuari, en aquest cas encara no està molt definit, ja que segurament, GEP es
farà servir com a complement per a Helios 2.0, però les entrades al programa son
clares:

Es disposa de resultats empírics (o bé per laboratori o bé utilitzant softwares
de simulació) sobre, per exemple, el volum d'una molècula en funció dels angles
dels seus enllaços rotables.

En un cas així, les dades d'entrada són els diferents angles i els volums
obtinguts, i el que es demana a la aplicació, és que a partir d'aquestes dades,
trobi una fórmula analítica que representi (amb la major fiabilitat possible)
aquestes dades, per a poder generalitzar les dades empíriques a una fórmula
tractable matemàticament.

El programa ha d'executar-se d'una tirada, amb el que no tindrà cap component de
interactivitat, ni es necessitarà cap tipus de emmagatzematge de dades
intermitges.

La entrada, doncs, es fa a través d'un paràmetre que ens indica on estan els
resultats que coneixem, juntament amb les dades que ens porten a aquests.

Juntament amb les dades, també s'han d'entrar els diferents paràmetres referents
al algorisme genètic.  Ara per ara no està implementat, però com es veurà en
l'apartat de treballs futurs(XXX), s'ha pensat permetre a l'usuari (se'l
considera un usuari ``expert'', que coneix tant el problema, com té coneixements
d'algorismes genètics) entrar ``building blocks'' addicionals, o
activar/desactivar els que ja venen per defecte.

Això suposa un gran repte a causa de les característiques estàtiques del
llenguatge, però ja s'han estudiat algunes maneres per a poder utilitzar
tècniques que permeten ``dinamitzar'' el llenguatge (utilitzant plugins o
llenguatges de scripting acoblats (embeded) al programa c++.
% subsection Interficie (end)


\subsection{Preparació de les dades} % (fold)
\label{sub:GPreparacio de dades}

La preparació de dades necessària per a aquest projecte no té massa rellevància,
ja que disposem a priori dels conjunts de dades d'entrada i resultats.

El programa simplement agafa les dades d'uns arxius que hem tractat amb uns
petits scripts per a tenir un format realment còmode.

Per a les proves que s'han realitzat per descubrir funcions matemàtiques
conegudes, la mateixa funció s'ha implementat en la funció d'evaluació, i
simplement, s'executa amb les dades d'entrada, per a tenir el resultat a
comparar-lo amb el resultat de la formula que estem evaluant.

% subsection Preparació de les dades (end)

\subsection{Implementació} % (fold)
\label{sub:GImplementacio}

Aquest projecte ha estat el més difícil d'implementar i disenyar, ja que hem
hagut de fer un treball notable d'investigació (els primers referents en GEP
daten de 2002 XXX).

El procés general del algoritme evolutiu és, donada una llargada de cromosoma,
decidida per l'usuari en funció de la complexitat ``intuitiva'' de la formula
que es vol descubrir, i uns paràmetres de probabilitat de creuaments i
mutacions, la aplicació ha de retornar una fórmula analítica que s'apropa (o
clava) la fórmula que estem buscant.
% subsection Impl (end)

(XXX) fer una seccio dedicada a GP i GEP o posar-ho a la implementació?

\subsubsection{Arbres} % (fold)
\label{ssub:Arbres}

Com s'ha explicat en \ref{introGEP i Procinf}, en GEP, la interpretació dels
cromosomes com a arbres a l'hora d'avaluar-se, fa que necessitem poder passar
del fenotip(lineal) al genotip (arbre) amb facilitat, i aquest genotip sigui
tractable com a tal, avaluant les seves característiques en l'entorn (calculant
l'arbre) de manera còmode, ràpida i eficient.

Per això s'ha desenvolupat un conjunt de classes per a tractar amb arbres, que
ens permeten construir i avaluar aquests arbres a partir d'un cromosoma (vector
de símbols).

Aquesta estructura, s'ha programat el més flexiblement possible, deixant la
possibilitat de ser extesa en un futur, afegint nous tipus d'operacions, i amb
diferents aritats, més grans de les que hem tingut necessitat fins al moment.

Nosaltres hem tractat només amb aritats 0,1 i dos (a € {0,1,2} ) ja que els
operands tenien un màxim de aritat 2.


 % theme=Berlin;caption_top=1;caption=Relació funció-aritat
 % simbol & aritat
 % + & 2
 % - & 2
 % * & 2
 % / & 2
 % sin & 1
 % cos & 1
 % sqrt (arrel quadrada) & 1
 % terminals (x,y,z..) & 0

\begin{table}
\centering
\caption{Relació funció-aritat}
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}{\textbf{simbol }} & \multicolumn{1}{c|}{\textbf{ aritat}} \\
\hline
\hline
+                     & 2 \\
-                     & 2 \\
*                     & 2 \\
/                     & 2 \\
sin                   & 1 \\
cos                   & 1 \\
sqrt (arrel quadrada) & 1 \\
terminals (x,y,z..)   & 0 \\
\hline
\end{tabular}
\end{table}

Per a poder construir un arbre complet, i avaluar-lo, a partir d'un vector de
simbols (implementats com a caràcters, donada la manca de símbols en c++ com a
tipus bàsic), i poder-ho fer amb la màxima robustesa i flexibilitat, s'ha
implemntat una estructura amb nodes, i un arbre tipus template.

Tot seguit es mostra el diagrama de classes d'aquesta part GEP.

%figura estructura de classes

Com es pot veure en la figura anterior (XXX ref fig), s'ha implementat una
classe abstracte Node de la que ``pengen'' les diferents especialitzacions, que
son les diferents operacions que suporta GEP, o bé els terminals. Els terminals,
com és d'esperar, tenen aritat zero, i al ser evaluats, retornen el valor del
terminal en aquest moment com a resultat.  Els operadors (aritat > 0),
requereixen d'altres nodes per a calcular el seu resultat.  D'això es deriva que
en un cromosoma donat, al transformarlo a genotip, les fulles seran totes
terminals, ja que son l'únic tipus de node que poden evaluar a un valor sense
necessitat de cap altre resultat precalculat.

Al haver-se de crear nodes dinàmicament (i intensament) durant cada execució,
s'ha utilitzat un patró \emph{Factory}, per facilitar la creació de nodes amb
una sintaxis extensible, per quan es vulguin afegir operadors, i per a fer més
còmode la seva utilització.

Després de implementar-se aquesta part, hem descobert una manera tant o més
elegant de fer-se aquest procés:  Utilitzant les llibreries Boost (XXX ref), que
ofereixen, entre d'altres, funcionalitatsl pròpies de llenguatges funcionals,
com per exemple Boost::Functional, que permet la programació de c++ retornant
funcions com a valor de retorn de una funció (programació d'ordre superior).  
D'aquesta manera, encara podem delegar un pas més avall la creació de nodes, 

arbres, nodes, evaluacio, etc.
patro estrategia + factory
Parlar de BOOST::Functional
% subsubsection Arbres (end)

\subsection{Algorisme Genètic} % (fold)
\label{ssec:GAlgorisme Genetic}

\subsubsection{Individu (Cromosoma)} % (fold)
\label{ssub:Individu (Cromosoma}

Per aquest s'han utilitzat els cromosomes representats com s'ha explicat en
l'apartat \ref{issub:individus}, però no només s'han utilitzat cromosomes amb un
gen, sinó que hem seguit dues altres maneres, més sofisticades per a representar
les nostres fórmules matemàtiques.

Aquests mètodes \cite (XXX) es basen en complicar una mica més el cromosoma,
però sempre fent servir la notacio karva \ref{XXX}.

Una de les millores, és encabir més d'un gen en un cromosoma. Fent això, el que
aconseguim és evolucionar dos subarbres, que en el moment de la avaluació,
s'uneixen d'alguna manera.

Si apliquem aquesta tècnica, es facilita la creació de subarbres que conformen
el que s'anomenen ``building blocks'', o blocks constructors que representen una
petita part (però significativa) de la fórmula que es vol acabar trobant.

EXEMPLE

Una de les maneres de combinar els diferents gens és utilitzant \emph{Link
functions} o funcions d'enllaç, que son operadors que decidim a priori, i
seràn els nodes arrel de l'arbre final.

En \ref{figXXX} es mostra com s'avaluarà el cromosoma mostrat abans amb funcions
d'enllaç suma.

Aquesta millora, dona molta flexibilitat al algorisme genètic, ja que li dona
poder per a fer combinacions entre diferents cromosomes (en el creuament), només
cambiant una part del arbre, i no fent cambis molt radicals al fenotip.  Aquest
procés de linkatge està també inspirat amb els procediments de la naturalesa per
a ensamblar proteïnes a partir de components més petites.

La següent implementació i millora és construir un gen una mica diferent en un
dels extrems del cromosoma, que contingui informació codificada sobre el propi
cromosoma.  Aquest tipus de metainformació és molt valuosa, i ens permet que el
propi cromosoma sàpiga com ensamblar-se i a més, ho pugui fer d'una manera
variable, que vagi evolucionant al mateix temps que evoluciona tot el propi gen.

El caire recursiu d'aquesta millora és una de les claus del bon funcionament de
GEP, ja que permet guardar una espècie d'``estat'', que ens dona dades sobre com
organitzar la pròpia informació que conté.

La manera de codificar-se, però, és molt similar a la que ja coneixem fins ara,
i gràcies a aquesta homogenietat, no s'han de fer tractaments especifics per a
aquesta metainformació ja que es codifica també amb forma d'un arbre amb notació
Karva, que en comptes d'utilitzar els terminals com a elements d'aritat zero, el
que s'utilitza com a elements ``de finalització'' són identificadors que es
refereixen als anteriors gens o ADT.

Com tots els gens, aquest gen especial, té un head i un tail, i en el seu head
es poden utilitzar els mateixos operadors que en la resta de heads.  Tot i així,
nosaltres hem reduit el nombre d'operadors a només $+,-,*,/$, descartant
operands com el sinus, cosinus i la arrel quadrada.

Com que el número de terminals diferents que pot tenir aquest meta-gen vé
determinat per el número total de gens amb els que configurem els cromosomes (el
número de terminals serà N-1 on N és el número total de gens), el número de gens
s'ha de saber al principi de la execució del programa, i no pot ser modificat
durant la execució (també violariem tota la homoiconicitat  d'un cromosoma respecte
els altres).

Per codificar aquests ``punters'' als ADTs, utilitzem números del 0..N-2
(seguint la mateixa notació anterior).

A continuació es mostra com un cromosoma multigènic homeòtic es codifica i
s'evalua.

% subsubsection Individu (Cromosoma (end)

\subsubsection{Inicialització} % (fold)
\label{ssub:Inicialitzacio}
La població inicial, inicialitza un número $N$ de cromosomes de manera
aleatòria.  La forma en què s'han d'inicialitzar els cromosomes és barrejant en
un mateix individu operadors i terminals, durant la ``zona de operadors'', o
\emph{head}, i omplint, només amb terminals la zona restant (cua o \emph{tail}).

Recordem que per a què un arbre (fenotip) sigui correcte, el genotip només ha de
complir la condició que en la darrera part del genotip, no hi hagi operadors.
La mida de la primera part es pot calcular de la següent manera:

Per a cada problema, es tria la llargada del head $h$.  Per a aquest head, la
llargada del \emph{tail} vé donada per una funció amb entrades $h$, i la major
aritat de tots els operadors que poden apareixer en el head $n$.

\begin{math}
t =  h (n-1) + 1
\end{math}

En el nostre cas, s'han implementat tres tipus diferents de cromosomes. Cal
tenir en compte, que aquí, la notació de GEP pot fer confondre, ja que es diu
``gen'' a cada arbre que es formarà en el fenotip, i no pas a cada posició
individual en el genotip.
%provar paragraph

\begin{itemize}
	\item Unigen : En cada cromosoma, només hi ha un gen.  Això vol dir que hi
	ha un \emph{head} i un \emph{tail}.
	\item Multigen-AD:
	\item Multigen homoiconic

\end{itemize}
% subsubsection Inicialització (end)

\subsubsection{Sel·lecció} % (fold)
\label{ssub:Seleccio}
torneig?
% subsubsection Sel·lecció (end)

\subsubsection{Creuament} % (fold)
\label{ssub:Creuament}

Creuaments, arbres subarbres blablba

tipus de creuaments
% subsubsection Creuament (end)

\subsubsection{Mutacions} % (fold)
\label{ssub:Mutacions}

es mante la simplicitat gracies a karva notation\ldots

transp
repla

% subsubsection Mutacions (end)
% section Algorisme Genètic (end)

% section Procediment informàtic (end)
    %Introducció
    %Context Químic
    %Procediment informàtic
    %+ Algoritme Genètic
    %+  Individu (Cromosoma)
    %+  Crossover
    %+  Mutacions
    %+ Implementació
    %+  algorisme genètic
    %+  Arxius de configuració
    %+  DBIx::Class
    %+  Webservices i Soap
    %Resultats
    %+ treball futur


\end{document}
